/** Infers TypeScript type from a JavaScript value. */
export function inferType(value: unknown): string {
  if (value === null) return 'null';
  if (value === undefined) return 'undefined';

  if (Array.isArray(value)) {
    if (value.length === 0) return 'unknown[]';
    const elementType = inferType(value[0]);
    return `${elementType}[]`;
  }

  const type = typeof value;
  if (type === 'object') return 'object';
  return type;
}

interface FieldInfo {
  name: string;
  type: string;
  optional: boolean;
  nestedFields?: Map<string, FieldInfo>;
}

/** Creates FieldInfo for a single key-value pair. */
function createFieldInfo(key: string, value: unknown): FieldInfo {
  const info: FieldInfo = {
    name: key,
    type: inferType(value),
    optional: false,
  };

  const isNestedObject = value !== null && typeof value === 'object' && !Array.isArray(value);
  if (isNestedObject) {
    info.nestedFields = analyzeFields([value]);
  }

  return info;
}

/** Analyzes items to determine field types and optionality. */
function analyzeFields(items: unknown[]): Map<string, FieldInfo> {
  const fields = new Map<string, FieldInfo>();
  const itemCount = items.length;

  for (const item of items) {
    if (typeof item !== 'object' || item === null) continue;

    const record = item as Record<string, unknown>;
    for (const [key, value] of Object.entries(record)) {
      if (!fields.has(key)) {
        fields.set(key, createFieldInfo(key, value));
      }
    }
  }

  // Mark fields as optional if not present in all items
  for (const [key, info] of fields) {
    const presentCount = items.filter(
      item => typeof item === 'object' && item !== null && key in item
    ).length;
    info.optional = presentCount < itemCount;
  }

  return fields;
}

/** Generates TypeScript interfaces from sample data. */
export function generateTypeScript(name: string, items: unknown[]): string {
  if (items.length === 0) return '';

  const fields = analyzeFields(items);
  const nestedInterfaces: string[] = [];

  // Generate nested interfaces first
  for (const [key, info] of fields) {
    if (info.nestedFields && info.nestedFields.size > 0) {
      const nestedName = `${name}${capitalize(key)}`;
      info.type = nestedName;

      const nestedFields = Array.from(info.nestedFields.entries())
        .map(([k, v]) => `  ${k}${v.optional ? '?' : ''}: ${v.type};`)
        .join('\n');

      nestedInterfaces.push(`export interface ${nestedName} {\n${nestedFields}\n}`);
    }
  }

  // Generate main interface
  const mainFields = Array.from(fields.entries())
    .map(([key, info]) => `  ${key}${info.optional ? '?' : ''}: ${info.type};`)
    .join('\n');

  const mainInterface = `export interface ${name} {\n${mainFields}\n}`;

  return [...nestedInterfaces, mainInterface].join('\n\n');
}

function capitalize(str: string): string {
  return str
    .split('_')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}

/** Writes TypeScript types to a file. */
export async function writeTypes(content: string, outputPath: string): Promise<void> {
  const header = '// Auto-generated by @skippy/cache - do not edit manually\n\n';
  await Bun.write(outputPath, header + content);
}
